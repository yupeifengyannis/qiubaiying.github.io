# 内存层次结构第一课

## 存储技术以及相应的发展趋势

### 随机访问存储器RAM

**关键的特性**

RAM是组织成一个芯片的结构，一个DRAM基本的一个单元叫做cell，每个cell中存有一个字节的数据，那下面我们来看看内存控制器是如何冲DRAM芯片中读取数据的。

![1552812537063](C:\Users\yupei\AppData\Local\Temp\1552812537063.png)

**读取步骤：**

1、内存控制器向内存芯片发送一个信号RAS（该信号是确定是哪一个行），而从图中我们可以看到，这个addr只有两个引脚，所以RAS表示的行号为(0, 1, 2, 3)。DRAM芯片接收到RAS信号之后，从supercells中将整一行给取出来，行读取完毕。

2、内存控制器继续给内存芯片发送一个信号CAS（该信号是用来确定哪一列），因为之前已经将行给选出来了，所以我们一旦确定列之后就可以知道自己所读数据的位置，然后选中那个cell的数据（每个cell的数据按道理来讲应该是一个字节byte），列读取完毕。

3、我们需要将读取的哪一个字节的数据传递给内存控制，这个就需要数据引脚来传递了，这边data引脚有8个位，所以可以传递一个字节大小的数据。

**如何从内存模块中读取一个64位大小的字**

首先我们得知道，一般我们的内存模块都是由好几个这样的DRAM芯片组合而成的，但是每个芯片我们只能从中读取一个字节byte，那我们如何读取一个字呢？见下图：

![1552813088003](C:\Users\yupei\AppData\Local\Temp\1552813088003.png)

如上图所示，一个内存模块中有8个DRAM芯片，比如我们想要读取某一个位置的内容，前面通过内存控制器等设备的转换，我们最终的读取地址是(i, j)这样的形式，然后通过广播的作用将读取(i, j)位置的信号发送给每一个supercell，然后每个DRAM读取一个字节的数据返回回来，这样8个DRAM芯片一并返回来就可以得到64位的数据。

**RAM分类**

一般我们将RAM分为SRAM和DRAM，一般SRAM访问时间快，造价贵一般是应用在缓存这种设备中的。而DRAM的访问时间慢，造价相对便宜，一般是使用在主存中，DRAM和SRAM对比表：

![1552819407155](C:\Users\yupei\AppData\Local\Temp\1552819407155.png)

### CPU和内存之间的数据传递

CPU和内存之间的数据传递过程要通过I/O桥，那这里将CPU和内存的交互分为**写操作**和**读操作**，具体过程看下面：

**写操作**

第一步：CPU将一个要读取的内存地址传递给内存bus。

![1552819921754](C:\Users\yupei\AppData\Local\Temp\1552819921754.png)

第二步：主存读取地址A的内容然后内容放到bus中。

![1552820150513](C:\Users\yupei\AppData\Local\Temp\1552820150513.png)

第三步：CPU从bus中读取相应的内容，然后将其拷贝到寄存器中。

![1552820191425](C:\Users\yupei\AppData\Local\Temp\1552820191425.png)

**写操作**

第一步：CPU将内存地址A给总线，然后内存读到这个地址A，然后等待相应的数据过来。

![1552820257257](C:\Users\yupei\AppData\Local\Temp\1552820257257.png)

第二步：CPU将相应的数据放到bus中。

![1552820293406](C:\Users\yupei\AppData\Local\Temp\1552820293406.png)

第三步：内存读取到相应的数据，然后将其放到地址A中了。

![1552820335214](C:\Users\yupei\AppData\Local\Temp\1552820335214.png)

### 磁盘的物理结构

每个Disk由platters组成，每个platter是由两个surface，每个surface是由若干个tracks组成，每个track可以被一些gaps分为若干个sectors。

![1552820483330](C:\Users\yupei\AppData\Local\Temp\1552820483330.png)

同时，整个磁盘中由相同大小的对齐tracks可以组成一个cylinder。

![1552820545432](C:\Users\yupei\AppData\Local\Temp\1552820545432.png)

### 磁盘容量

一般的供应商提供的磁盘的容量都是在GB和TB这个级别的，其中1GB = 10^9 Bytes, 1TB = 10^12 Bytes。

Recording density：单位为（bits/in）相当于每英寸单位的track上有多少的位被记录。

Track density：单位为（tracks/in）径向每单位英寸上面的tracks数。

Areal density：单位为（bits/in^2），将Recording density和Track density相乘得到的结果。

**磁盘容量的计算公式：**

capacity = （#bytes/sector）* （#sectors/track）*（#tracks/surface）\*（#surfaces/platter）\*（#platters/disk）

### 磁盘操作：单个platter的视角

![1552821861191](C:\Users\yupei\AppData\Local\Temp\1552821861191.png)

整个磁盘是围着一个轴进行旋转的，而这读写头可以在不同的track之间进行切换，读写头和track之间有一个小气隙，因为转速很快，如果将磁头和track贴在一起的话，磁头会碎掉，所以有个气隙进行保护。一般这个磁盘内部空间要高度干净，不能由灰尘这样的东西， 因为在实际运行撞到磁头的话，会导致磁头损坏。

### 磁盘访问

![1552822131931](C:\Users\yupei\AppData\Local\Temp\1552822131931.png)

一般我们可以将整个磁盘访问的时间分为三个部分：

1、寻址的时间（seek time），因为我们要从一个track切换到另外一个track中，这个过程叫做seek。一般在3-9ms左右，所占时间最多。

2、旋转延迟（Rotational latency），我们在找到的track中要旋转到需要读取数据的起始位置，这个时间叫旋转延迟。

3、数据传输时间（transfer time），将一个sector或者多个sector的数据通过磁头传到内存中。

所以磁盘访问的时间为：

Taccess = Tavgseek + Tavg rotation + Tavg transfer

### 从磁盘读数据的过程

![1552822500261](C:\Users\yupei\AppData\Local\Temp\1552822500261.png)

这个时整个计算机的内部硬件结构，而磁盘这个设备是通过I/Obus来与CPU和主存相连的，I/Obus的访问速度比一般的system bus和memory bus的访问速度要来得慢。另外我们看到磁盘上面挂了一个磁盘控制器的玩意，关于这个玩意的作用，因为我们想在也是将磁盘当作一块一块来处理，我们给磁盘控制器发送相应的地址，然后磁盘控制器会将这个地址进行翻译，最后找到相应的磁盘位置并将读取或者写入数据。

**具体过程：**

第一步：CPU发起一个磁盘读操作，我们给磁盘控制器发送相应的逻辑磁盘块号，目的内存地址。

第二步：磁盘控制器将目的sector的数据读取出来，然后将其传递给主存中。

第三步：当数据传入到主存这个步骤完成之后，磁盘控制器会给CPU发送一个中断信号，告诉操作系统我现在数据已经加载完毕了。

### 固态硬盘（SSD）

![1552822953134](C:\Users\yupei\AppData\Local\Temp\1552822953134.png)

固态硬盘里面闪存，闪存分为好几个块，每个块又分为好几个页。这个和后面的虚拟内存有点类似，每次读写数据都是一个页或者多个页一起进行的。而且写操作只能在闪存被擦出操作之后进行，一般一个块写个100000次左右就没有用了。

**SSD访问的一些特点**

1、顺序访问要比随机访问速度块，这和后面的内存层次结构介绍的概念有点类似。

2、随机写比较慢，因为在写之前要进行擦出操作，这个是要花时间的。

### 一个重要问题：CPU-Memory Gap

![1552823233897](C:\Users\yupei\AppData\Local\Temp\1552823233897.png)

从这张图中可以看到，内存访问和CPU访问寄存器的速度差别相当大，那该怎么办呢？但是幸好，我们一般的程序都是由局部性这个属性的，局部性可以分为时间局部性和空间局部性。

时间局部性：一个数据现在用过，同时在不久的将来也会继续用到。

空间局部性：CPU要访问的数据往往都是凑在一起的。

### 内存层次结构

直接上图，不多解释。

![1552823445730](C:\Users\yupei\AppData\Local\Temp\1552823445730.png)

![1552823701675](C:\Users\yupei\AppData\Local\Temp\1552823701675.png)

### 缓存概念

1、cold miss，开始访问缓存的时候，这个时候缓存还是空的，所以一访问就出现了miss，这种miss叫做cold miss。

2、capacity miss：CPU要经常访问的数据集大于缓存的大小，这样就会导致capacity miss。其实还会导致相应的thrashing。

3、conflict miss：这个是后面要着重分析的一种miss，意思是缓存的空间还有多余，但是由于缓存映射函数的关系，两次不同的访问数据访问到同一个地方，然后导致了conflict miss。











































