# 内存层次结构第二课

### 缓存所在位置

一般缓存是比较小的快速的SRAM组成的内存，它是通过计算机硬件来直接进行管理的。一般CPU在寻找数据的时候会瞅瞅缓存中有没有数据了，其一般的典型的结构如下图所示：

![1552827915064](C:\Users\yupei\AppData\Local\Temp\1552827915064.png)



### 通用缓存组织结构(S, E, B)

![1552828096857](C:\Users\yupei\AppData\Local\Temp\1552828096857.png)

如上图所示：

S为缓存集合的个数，这里S=2^s。

E为每个集合中line的个数，E=2^e，这里的小e后面没怎么用到过。

B为每个line中的字节的数目，B=2^b。

所以整个缓存的大小定义为：SIZE = S * E * B bytes。

那我们继续看每条line中包含哪些信息：

valid位——表示这个缓存是否合法，通常是用来判断是否有数据存在该缓存上。

tag位——因为有不同的内存数据会映射到用一个缓存当中，所以这个tag为是不同数据的一个身份标识符。

B——后面会跟着B位的字节。

### 如何读缓存呢

![1552828448199](C:\Users\yupei\AppData\Local\Temp\1552828448199.png)

在介绍如何读缓存之前，我们来看一下要访问的物理地址的结构，这里它是由三部分组成的。第一部分是tag位置，这里的tag位有t位，第二部分是set位置，这里的set位有s位置，最后是block offset位置，这里有b位置，那么它们和前面介绍的缓存结构有啥联系呢？

S = 2 ^ s;

B = 2 ^ b;

剩余的位都是tag位置。

**读缓存的步骤（这里我们假设成功读缓存）：**

1、定位set的index，这主要是通过中间的s个bits来定位。

2、利用tag的信息来检查set中是否有line匹配。

3、检查line的valid位。

4、利用block offset信息来决定相应的数据所在B中的哪个地方。

### 直接映射缓存

直接映射缓存是要求缓存中每个集合中只有一条line。

那具体看是如何对应的吧：

![1552828988651](C:\Users\yupei\AppData\Local\Temp\1552828988651.png)

首先我们读取一个内存地址，这个内存地址存的是一个int，这个int 的大小为4字节。那我们可以通过上述的寻找方法来确定具体的int的内容。但是如果tag不匹配或者valid为false的话，那么说明发生了相应的miss情况。如果是cold miss的话，那么应该要从内存中将数据给读入到缓存中。如果是conflict miss的话，那么这个时候应该要选中一个line，然后将这个line给替换掉。

### E-way组相连缓存

![1552829202861](C:\Users\yupei\AppData\Local\Temp\1552829202861.png)

![1552829225311](C:\Users\yupei\AppData\Local\Temp\1552829225311.png)

这个时候传来一个物理地址，在确定号组之后，我们需要将这个物理地址中的tag与组中每条line进行对比从而确定相应的line。

### 那如何写缓存呢？

写缓存和读缓存不太一样，我们简单看一下缓存的组织结构。

![1552829415174](C:\Users\yupei\AppData\Local\Temp\1552829415174.png)

和之前相比，写缓存需要加入一个dirty bit，用来判断该缓存是否已经被修改过了。

**几个概念：**

**write-hit**

write-through——直接将数据写回内存。

write-back——将写这个操作推迟到line替换的时候，如果dirty位被设置了，那么说明该内容有变化。

**write-miss**

write-allocate——将数据块加载到缓存中，然后配合相应的write-back技术在换line的时候将数据写回。

no-write-allocate——直接将数据写回到内存中，不需要分配相应分配，这个和write-through直接搭配使用。

**典型的搭配方式：**

write-through + no-write-allocate

write-back + write-allocate

### 为甚使用中间的位来组为set index bits呢？

因为使用中间位置作为set index bits的话可以大大提高空间局部性，因为这样一来在内存中相邻的两块区域映射到缓存中的相同的组的机会就会少很多，这样可以大幅的减低conflict miss的概率。

### 缓存性能指标

1、Miss Rate：Miss rate一般是指缓存寻找过程中不匹配的概率，一般是= 1 - hit rate，一般对于L1级缓存来说miss rate在3 - 10%左右。而一般L2缓存或者后面的缓存的miss rate都更加的小。

2、Hit Time，将缓存中的line的数据或者指令读取出来传递给处理器的时间，一般对于L1缓存来说是4个时钟周期，对于L2缓存来说是10个时钟周期。

3、Miss Penalty：如果cache miss了，我们只能要到下一级缓存中去寻找，而这个操作本身的开销是非常大的。比如如果我们要从主存中寻找相应的数据或者指令的话，这个时间大概是50-200个时钟周期。

### 写缓存友好型代码

关注循环里面的代码，尽量使用缓存的时间局部性和空间局部性这两大局部性的特性。



















